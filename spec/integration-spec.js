const syncSettings = require('../lib/main')
const GistApi = require('../lib/location/gist')
const SyncSettings = require('../lib/sync-settings')
const fs = require('fs')
const util = require('util')
const writeFile = util.promisify(fs.writeFile)
const readFileAsync = util.promisify(fs.readFile)
const readFile = (file) => readFileAsync(file, { encoding: 'utf8' })
const unlink = util.promisify(fs.unlink)
const path = require('path')

describe('integration', () => {
	it('should activate and deactivate without error', async () => {
		atom.config.set('sync-settings.checkForUpdatedBackup', false)
		spyOn(console, 'error').and.callThrough()
		await atom.packages.activatePackage('sync-settings')
		// wait for package to activate
		await syncSettings.activationPromise
		await atom.packages.deactivatePackage('sync-settings')

		expect(console.error).not.toHaveBeenCalled()
	})

	it('should check backup on activation', async () => {
		spyOn(SyncSettings.prototype, 'checkBackup')
		spyOn(atom.packages, 'hasActivatedInitialPackages').and.returnValue(true)
		await atom.packages.activatePackage('sync-settings')
		await syncSettings.activationPromise

		expect(SyncSettings.prototype.checkBackup).toHaveBeenCalled()

		await atom.packages.deactivatePackage('sync-settings')
	})

	describe('commands', () => {
		beforeEach(async () => {
			atom.config.set('sync-settings.backupLocation', 'gist')
			await atom.packages.activatePackage('sync-settings')
			await syncSettings.activationPromise
		})

		afterEach(async () => {
			await atom.packages.deactivatePackage('sync-settings')
		})

		it('backup', async () => {
			spyOn(SyncSettings.prototype, 'backup')
			await atom.commands.dispatch(atom.views.getView(atom.workspace), 'sync-settings:backup')

			expect(SyncSettings.prototype.backup).toHaveBeenCalled()
		})

		it('restore', async () => {
			spyOn(SyncSettings.prototype, 'restore')
			await atom.commands.dispatch(atom.views.getView(atom.workspace), 'sync-settings:restore')

			expect(SyncSettings.prototype.restore).toHaveBeenCalled()
		})

		it('view backup', async () => {
			spyOn(SyncSettings.prototype, 'viewBackup')
			await atom.commands.dispatch(atom.views.getView(atom.workspace), 'sync-settings:view-backup')

			expect(SyncSettings.prototype.viewBackup).toHaveBeenCalled()
		})

		it('check backup', async () => {
			spyOn(SyncSettings.prototype, 'checkBackup')
			await atom.commands.dispatch(atom.views.getView(atom.workspace), 'sync-settings:check-backup')

			expect(SyncSettings.prototype.checkBackup).toHaveBeenCalled()
		})

		it('fork backup', async () => {
			spyOn(SyncSettings.prototype, 'fork')
			await atom.commands.dispatch(atom.views.getView(atom.workspace), 'sync-settings:fork')

			expect(SyncSettings.prototype.fork).toHaveBeenCalled()
		})
	})

	// FIXME: not sure why linux api test is timing out
	if (process.env.GITHUB_TOKEN && process.platform !== 'linux') {
		describe('API', () => {
			let gistApi
			beforeEach(async () => {
				await writeFile(atom.keymaps.getUserKeymapPath(), '# keymap')
				await writeFile(atom.styles.getUserStyleSheetPath(), '// stylesheet')
				await writeFile(atom.getUserInitScriptPath(), '# init')
				await writeFile(path.resolve(atom.getConfigDirPath(), 'snippets.cson'), '# snippets')

				atom.config.set('sync-settings.gistSettings.gistDescription', 'Test gist by Sync Settings for Atom https://github.com/atom-community/sync-settings')
				gistApi = new GistApi()

				await gistApi.create()
				await atom.packages.activatePackage('sync-settings')
				await syncSettings.activationPromise
			})

			afterEach(async () => {
				await gistApi.delete()
				await atom.packages.deactivatePackage('sync-settings')
				await unlink(atom.keymaps.getUserKeymapPath())
				await unlink(atom.styles.getUserStyleSheetPath())
				await unlink(atom.getUserInitScriptPath())
				await unlink(path.resolve(atom.getConfigDirPath(), 'snippets.cson'))
			})

			it('backs up files', async () => {
				atom.config.set('sync-settings.gistSettings.gistDescription', 'automatic update by http://atom.io/packages/sync-settings')
				await atom.commands.dispatch(atom.views.getView(atom.workspace), 'sync-settings:backup')
				const gist = await gistApi.get()
				expect(gist).toEqual({
					time: jasmine.stringMatching(/^\d\d\d\d-\d\d-\d\dT\d\d:\d\d:\d\dZ$/),
					history: [
						jasmine.objectContaining({
							version: jasmine.stringMatching(/^\w+$/),
						}),
						jasmine.objectContaining({
							version: jasmine.stringMatching(/^\w+$/),
						}),
					],
					files: {
						README: jasmine.objectContaining({
							content: '# Generated by Sync Settings for Atom\n\n<https://github.com/atom-community/sync-settings>',
							filename: 'README',
						}),
						'init.coffee': jasmine.objectContaining({
							content: '# init',
							filename: 'init.coffee',
						}),
						'keymap.cson': jasmine.objectContaining({
							content: '# keymap',
							filename: 'keymap.cson',
						}),
						'packages.json': jasmine.objectContaining({
							content: jasmine.stringMatching(/about/),
							filename: 'packages.json',
						}),
						'settings.json': jasmine.objectContaining({
							content: jasmine.stringMatching(/"sync-settings":/),
							filename: 'settings.json',
						}),
						'snippets.cson': jasmine.objectContaining({
							content: '# snippets',
							filename: 'snippets.cson',
						}),
						'styles.less': jasmine.objectContaining({
							content: '// stylesheet',
							filename: 'styles.less',
						}),
					},
				})
			}, (process.env.CI ? 60 : 10) * 1000)

			it('restores files', async () => {
				atom.config.set('sync-settings.extraFiles', ['README'])
				await atom.commands.dispatch(atom.views.getView(atom.workspace), 'sync-settings:restore')
				const readme = await readFile(path.resolve(atom.getConfigDirPath(), 'README'))

				expect(readme).toBe('# Generated by Sync Settings for Atom\n\n<https://github.com/atom-community/sync-settings>')
			}, (process.env.CI ? 60 : 10) * 1000)

			it('backs up and restores paths with slash', async () => {
				atom.config.set('sync-settings.extraFiles', ['../test.tmp'])
				const tmpPath = path.resolve(atom.getConfigDirPath(), '../test.tmp')
				await writeFile(tmpPath, 'test.tmp')
				try {
					await atom.commands.dispatch(atom.views.getView(atom.workspace), 'sync-settings:backup')
					await unlink(tmpPath)
					await atom.commands.dispatch(atom.views.getView(atom.workspace), 'sync-settings:restore')
					const content = await readFile(tmpPath)

					expect(content).toBe('test.tmp')
				} finally {
					await unlink(tmpPath)
				}
			}, (process.env.CI ? 60 : 10) * 1000)

			it('does not delete a file with only whitespace', async () => {
				atom.config.set('sync-settings.extraFiles', ['README'])
				await writeFile(path.resolve(atom.getConfigDirPath(), 'README'), '\n \t')
				await atom.commands.dispatch(atom.views.getView(atom.workspace), 'sync-settings:backup')
				const data = await gistApi.get()
				expect('README' in data.files).toBe(true)
				expect(data.files.README.content).toContain('(not found)')
			}, (process.env.CI ? 60 : 10) * 1000)
		})
	}
})
